<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Thrust Stand V4</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --card-color: #16213e;
            --primary-color: #0f3460;
            --accent-color: #e94560;
            --pwm-color: #1E90FF;
            --text-color: #e0e0e0;
            --header-height: 64px;
            --sidebar-width: 320px;
            --font-family: 'Roboto', sans-serif;
        }

        body {
            font-family: var(--font-family);
            background: radial-gradient(1200px 600px at 20% -10%, #243460 0%, #1a1a2e 55%, #0f121f 100%);
            color: var(--text-color);
            margin: 0;
            min-height: 100vh;
        }

        .app {
            display: grid;
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: auto 1fr;
            gap: 1.25rem;
            padding: 1.25rem;
            min-height: 100vh;
        }

        .topbar {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            padding: 0.85rem 1rem;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(15, 52, 96, 0.55), rgba(22, 33, 62, 0.8));
            border: 1px solid rgba(233, 69, 96, 0.25);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(8px);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 0.9rem;
        }

        .brand-mark {
            width: 42px;
            height: 42px;
            border-radius: 12px;
            background: linear-gradient(145deg, #e94560, #7c2231);
            display: grid;
            place-items: center;
            font-weight: 700;
            letter-spacing: 0.08em;
            color: white;
        }

        .brand-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 0;
        }

        .brand-subtitle {
            margin: 0.15rem 0 0 0;
            font-size: 0.85rem;
            color: #b9c2d6;
        }

        .topbar-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .test-name-display {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.4rem 0.75rem;
            border-radius: 12px;
            background: rgba(15, 52, 96, 0.45);
            border: 1px solid rgba(233, 69, 96, 0.25);
            min-width: 180px;
        }

        .test-name-label {
            font-size: 0.7rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #b9c2d6;
        }

        .test-name-value {
            font-size: 1rem;
            font-weight: 700;
            color: #f5f7ff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 320px;
        }

        .sim-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.65rem;
            border-radius: 999px;
            border: 1px solid rgba(233, 69, 96, 0.35);
            background: rgba(0, 0, 0, 0.25);
            font-size: 0.85rem;
        }

        .sim-toggle span {
            color: #c9d0e1;
            font-weight: 600;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background: rgba(255, 255, 255, 0.15);
            transition: 0.2s;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            top: 2px;
            background: #e0e0e0;
            transition: 0.2s;
            border-radius: 50%;
        }

        .switch input:checked + .slider {
            background: rgba(46, 204, 113, 0.35);
            border-color: rgba(46, 204, 113, 0.6);
        }

        .switch input:checked + .slider:before {
            transform: translateX(20px);
            background: #2ecc71;
        }

        .status-pill {
            display: flex;
            align-items: center;
            gap: 0.45rem;
            padding: 0.35rem 0.8rem;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--primary-color);
            font-size: 0.85rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #dc3545;
            box-shadow: 0 0 8px rgba(220, 53, 69, 0.8);
        }

        .status-pill[data-state="connected"] {
            border-color: #2ecc71;
            color: #c7f5d5;
        }

        .status-pill[data-state="connected"] .status-dot {
            background: #2ecc71;
            box-shadow: 0 0 8px rgba(46, 204, 113, 0.9);
        }

        .topbar-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            border: 1px solid rgba(233, 69, 96, 0.5);
            background: rgba(233, 69, 96, 0.15);
            color: #f6c1cb;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 600;
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .topbar-btn:hover {
            transform: translateY(-1px);
            background: rgba(233, 69, 96, 0.3);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            position: sticky;
            top: 1.25rem;
            align-self: start;
        }

        .sidebar .card {
            padding: 1.1rem;
        }

        .sidebar-nav {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sidebar-nav a {
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-color);
            border: 1px solid transparent;
            background: rgba(0, 0, 0, 0.2);
            transition: border 0.2s ease, transform 0.2s ease;
        }

        .sidebar-nav a:hover {
            border: 1px solid var(--primary-color);
            transform: translateX(3px);
        }

        .main {
            min-width: 0;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
        }

        .card {
            background-color: var(--card-color);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--primary-color);
        }

        .card-title {
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--accent-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        .chart-container {
            position: relative;
            height: 55vh;
            grid-column: 1 / -1;
        }

        .live-timer {
            position: absolute;
            bottom: 45px; /* Adjust to be above x-axis labels */
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 5px 15px;
            border-radius: 8px;
            font-size: 1.4rem;
            font-family: monospace;
            z-index: 10;
        }

        .live-data {
            display: flex;
            justify-content: space-around;
            text-align: center;
            margin-bottom: 1rem;
        }
        .live-data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 0.5rem 1.5rem;
            justify-items: center;
            align-items: center;
            margin-bottom: 1rem;
        }

        .data-box h3 { margin: 0 0 0.5rem 0; font-weight: 300; font-size: 1rem; text-transform: uppercase; }
        .data-box p { margin: 0; font-size: 2.25rem; font-weight: 700; }
        #currentThrust { color: var(--accent-color); }
        #currentPwm { color: var(--pwm-color); }

        .controls button, .export-controls button {
            width: 100%; padding: 1rem; font-size: 1.2rem; font-weight: 700;
            border: none; border-radius: 10px; cursor: pointer;
            transition: all 0.3s ease; color: white; margin-bottom: 0.5rem;
        }

        #startBtn { background-color: #28a745; }
        #startBtn:hover { background-color: #218838; }
        #stopBtn { background-color: #dc3545; }
        #stopBtn:hover { background-color: #c82333; }
        #resetBtn { background-color: #ffc107; color: #333; }
        #resetBtn:hover { background-color: #e0a800; }
        
        #exportBtn { background-color: #17a2b8; }
        #exportBtn:hover { background-color: #138496; }
        #exportBtn:disabled { background-color: #5a6268; cursor: not-allowed; }

        .form-group { margin-bottom: 1rem; }
        .form-group label { display: block; margin-bottom: 0.5rem; font-weight: bold; }
        .form-group input, .form-group textarea {
            width: calc(100% - 22px); padding: 10px; border-radius: 5px;
            border: 1px solid var(--primary-color); background-color: var(--bg-color);
            color: var(--text-color); font-family: monospace; font-size: 1rem;
        }
        .form-group textarea { resize: vertical; height: 80px; }
        .help-text { font-size: 0.8rem; color: #aaa; margin-top: 5px; }

        #summaryStats p { margin: 0.5rem 0; font-size: 1rem; }
        #summaryStats strong { color: var(--pwm-color); }
        #summaryStats span { color: var(--text-color); font-weight: bold; }

        #statusLog {
            background-color: rgba(0,0,0,0.2); height: 120px; border-radius: 5px;
            padding: 10px; overflow-y: scroll; font-family: monospace;
            font-size: 0.9rem; border: 1px solid var(--primary-color);
        }
        #statusLog p { margin: 0 0 5px 0; }
        .error-log { color: #ff4d4d; font-weight: bold; }

        .scale-factor-group {
            margin-bottom: 1.5rem;
            background: rgba(0,0,0,0.08);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--primary-color);
        }
        .scale-factor-group label {
            font-weight: bold;
            margin-right: 1rem;
        }
        .scale-factor-group input[type="number"] {
            width: 120px;
            font-size: 1.1rem;
            padding: 6px 10px;
            border-radius: 5px;
            border: 1px solid var(--primary-color);
            background: var(--bg-color);
            color: var(--text-color);
            margin-right: 1rem;
        }
        .scale-factor-group button {
            padding: 6px 18px;
            font-size: 1.1rem;
            border-radius: 6px;
            border: none;
            background: var(--accent-color);
            color: white;
            cursor: pointer;
            font-weight: 700;
            transition: background 0.2s;
        }
        .scale-factor-group button:hover {
            background: #b92d3a;
        }

        .config-btn {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            border-radius: 8px;
            border: none;
            background: var(--primary-color);
            color: white;
            cursor: pointer;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .config-btn:hover { opacity: 0.9; }
        .board-config-editor {
            width: 100%;
            min-height: 320px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            padding: 0.75rem;
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            background: var(--bg-color);
            color: var(--text-color);
            resize: vertical;
        }

        .settings-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1100;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }

        .settings-panel {
            width: min(920px, 96vw);
            max-height: 90vh;
            overflow-y: auto;
            background: #16213e;
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid rgba(233, 69, 96, 0.35);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        }

        .settings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .settings-header h2 {
            margin: 0;
            color: var(--accent-color);
        }

        .settings-close {
            padding: 0.4rem 0.75rem;
            border-radius: 8px;
            border: 1px solid rgba(233, 69, 96, 0.5);
            background: rgba(233, 69, 96, 0.15);
            color: #f6c1cb;
            font-weight: 700;
            cursor: pointer;
        }

        @media (max-width: 980px) {
            .app {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: static;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
                align-items: start;
            }

            .topbar {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        @media (max-width: 640px) {
            .app {
                padding: 0.75rem;
            }

            .chart-container {
                height: 45vh;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="topbar">
            <div class="brand">
                <div class="brand-mark">TS</div>
                <div>
                    <p class="brand-title">ESP32 Thrust Stand</p>
                    <p class="brand-subtitle">Realtime thrust + telemetry</p>
                </div>
            </div>
            <div class="test-name-display" aria-live="polite">
                <span class="test-name-label">Test Name</span>
                <span class="test-name-value" id="testNameDisplay">--</span>
            </div>
            <div class="topbar-actions">
                <div class="status-pill" id="wsStatus" data-state="disconnected">
                    <span class="status-dot"></span>
                    <span id="wsText">Disconnected</span>
                </div>
                <div class="sim-toggle" title="Requires reboot to apply">
                    <span>Live</span>
                    <label class="switch">
                        <input type="checkbox" id="simToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Sim</span>
                </div>
                <button class="topbar-btn" id="topbarRebootBtn" type="button">Reboot</button>
                <button class="topbar-btn" id="settingsOpenBtn" type="button">Settings</button>
            </div>
        </header>

        <aside class="sidebar">
            <div class="card">
                <h2 class="card-title">Quick Controls</h2>
                <div class="controls">
                    <button id="startBtn">START TEST</button>
                    <button id="stopBtn">STOP TEST</button>
                    <button id="resetBtn">RESET</button>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Live Data</h2>
                <div class="live-data live-data-grid">
                    <div class="data-box">
                        <h3>Thrust (g)</h3>
                        <p id="currentThrust">0.00</p>
                    </div>
                    <div class="data-box">
                        <h3>PWM (μs)</h3>
                        <p id="currentPwm">1000</p>
                    </div>
                    <div class="data-box">
                        <h3>Voltage (V)</h3>
                        <p id="currentVoltage">--</p>
                    </div>
                    <div class="data-box">
                        <h3>Current (A)</h3>
                        <p id="currentCurrent">--</p>
                    </div>
                </div>
            </div>

            <div class="card" id="summaryCard" style="display: none;">
                <h2 class="card-title">Test Summary</h2>
                <div id="summaryStats">
                    <p><strong>Max Thrust:</strong> <span id="summaryMaxThrust">0</span> g</p>
                    <p><strong>Max PWM:</strong> <span id="summaryMaxPwm">0</span> µs</p>
                    <p><strong>Time near Max Thrust (-50g):</strong> <span id="summaryTimeAtMax">0</span> s</p>
                    <p><strong>Total Test Duration:</strong> <span id="summaryTotalTime">0</span> s</p>
                </div>
                <div class="export-controls" style="margin-top: 1rem;">
                    <button id="exportBtn" disabled>Export CSV Results</button>
                </div>
            </div>

        </aside>

        <main class="main">
            <div class="container">
                <div class="card chart-container" id="chartCard">
                    <canvas id="thrustChart"></canvas>
                    <div id="liveTimer" class="live-timer">0.00s</div>
                </div>

                <div class="card" id="statusLogCard" style="grid-column: 1 / -1;">
                    <h2 class="card-title">Status Log</h2>
                    <div id="statusLog"></div>
                </div>

            </div>
        </main>
    </div>

    <div id="settingsModal" class="settings-modal">
        <div class="settings-panel">
            <div class="settings-header">
                <h2>Settings</h2>
                <button class="settings-close" id="settingsCloseBtn" type="button">Close</button>
            </div>

            <div class="card" style="margin-bottom:1rem;">
                <h2 class="card-title">Test Information</h2>
                <div class="form-group">
                    <label for="testName">Test Name</label>
                    <input type="text" id="testName">
                </div>
                <div class="form-group">
                    <label for="testDetails">Test Details & Profile</label>
                    <textarea id="testDetails"></textarea>
                    <p class="help-text">Tip: Capture motor, prop, battery, and Test Profile line.</p>
                </div>
            </div>

            <div class="card" style="margin-bottom:1rem;">
                <h2 class="card-title">Calibration</h2>
                <div style="margin-bottom:1rem;">
                    <button id="calibrateBtn" style="width:100%;padding:1rem;font-size:1.2rem;font-weight:700;background:#17a2b8;color:white;border:none;border-radius:10px;cursor:pointer;">Calibrate Weight</button>
                </div>
                <div id="calibrationStatus" style="font-size:1rem;color:#aaa;"></div>
            </div>

            <div class="card">
                <h2 class="card-title">Board configuration</h2>
                <p class="help-text" style="margin-bottom:1rem;">Config is stored on the board and is not deleted. Changes to pins and ESC require a reboot to apply.</p>
                <div style="margin-bottom:0.5rem;">
                    <button type="button" id="configLoadBtn" class="config-btn">Load from board</button>
                    <button type="button" id="configDefaultBtn" class="config-btn">Load default</button>
                    <button type="button" id="configValidateBtn" class="config-btn">Validate</button>
                    <button type="button" id="configSaveBtn" class="config-btn" style="background:var(--accent-color);">Save to board</button>
                    <button type="button" id="configRebootBtn" class="config-btn">Reboot to apply</button>
                </div>
                <textarea id="boardConfigEditor" class="board-config-editor" spellcheck="false" placeholder="Load from board to edit..."></textarea>
                <div id="configStatus" style="margin-top:0.5rem;font-size:0.9rem;color:#aaa;"></div>
            </div>
        </div>
    </div>

    <!-- Calibration Modal -->
    <div id="calibrationModal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.6);z-index:1000;align-items:center;justify-content:center;">
        <div style="background:#16213e;padding:2rem 2.5rem;border-radius:15px;box-shadow:0 8px 32px #000a;min-width:320px;max-width:90vw;margin:auto;">
            <h2 style="margin-top:0;color:#e94560;">Scale Calibration</h2>
            <div style="margin-bottom:1rem;">
                <strong>Current Scale Factor:</strong>
                <input type="number" id="modalScaleFactorInput" style="width:110px;font-size:1.1rem;padding:4px 8px;border-radius:5px;border:1px solid #0f3460;background:#1a1a2e;color:#e0e0e0;margin-left:0.5rem;" step="0.01">
            </div>
            <div style="margin-bottom:1rem;">
                <strong>Measured Weight:</strong> <span id="modalMeasuredWeight">0.00</span> g
            </div>
            <div style="margin-bottom:1rem;">
                <label for="modalTargetWeight"><strong>Target Weight (g):</strong></label>
                <input type="number" id="modalTargetWeight" style="width:100px;font-size:1.1rem;padding:4px 8px;border-radius:5px;border:1px solid #0f3460;background:#1a1a2e;color:#e0e0e0;margin-left:0.5rem;">
            </div>
            <div style="margin-bottom:1.5rem;">
                <button id="modalCaptureBtn" style="padding:0.7rem 2rem;font-size:1.1rem;font-weight:700;background:#28a745;color:white;border:none;border-radius:8px;cursor:pointer;">Capture</button>
                <button id="modalCancelBtn" style="padding:0.7rem 2rem;font-size:1.1rem;font-weight:700;background:#dc3545;color:white;border:none;border-radius:8px;cursor:pointer;margin-left:1rem;">Close</button>
            </div>
            <div id="modalCalibMsg" style="color:#aaa;font-size:1rem;"></div>
        </div>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const authToken = urlParams.get('token') || '';
        const authQuery = authToken ? `?token=${encodeURIComponent(authToken)}` : '';
        const authUrl = (path) => authToken ? `${path}${path.includes('?') ? '&' : '?'}token=${encodeURIComponent(authToken)}` : path;
        const authHeaders = (extra = {}) => {
            if (!authToken) return extra;
            return Object.assign({ 'X-Auth-Token': authToken }, extra);
        };

        let gateway = `ws://${window.location.hostname}/ws${authQuery}`;
        let websocket;
        let heartbeatTimer = null;
        let thrustChart;
        let finalTestResults = [];
        let resultsSaved = true;
        let finalResultsReceiving = false;
        let expectedFinalTotal = 0;
        let currentScaleFactor = -204.0; // Default
        let currentRawReading = 0;
        let currentMeasuredWeight = 0;
        let plannedMaxSeconds = null;

        // DOM Elements
        const currentThrustEl = document.getElementById('currentThrust');
        const currentPwmEl = document.getElementById('currentPwm');
        const currentVoltageEl = document.getElementById('currentVoltage');
        const currentCurrentEl = document.getElementById('currentCurrent');
        const statusLogEl = document.getElementById('statusLog');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const exportBtn = document.getElementById('exportBtn');
        const testNameInput = document.getElementById('testName');
        const testDetailsInput = document.getElementById('testDetails');
        const liveTimerEl = document.getElementById('liveTimer');
        const summaryCardEl = document.getElementById('summaryCard');
        const wsStatusEl = document.getElementById('wsStatus');
        const wsTextEl = document.getElementById('wsText');
        const simToggleEl = document.getElementById('simToggle');
        const topbarRebootBtn = document.getElementById('topbarRebootBtn');
        const settingsOpenBtn = document.getElementById('settingsOpenBtn');
        const settingsCloseBtn = document.getElementById('settingsCloseBtn');
        const settingsModal = document.getElementById('settingsModal');
        const testNameDisplay = document.getElementById('testNameDisplay');

        // Calibration modal DOM
        const calibrateBtn = document.getElementById('calibrateBtn');
        const calibrationModal = document.getElementById('calibrationModal');
        const modalScaleFactorInput = document.getElementById('modalScaleFactorInput');
        const modalMeasuredWeight = document.getElementById('modalMeasuredWeight');
        const modalTargetWeight = document.getElementById('modalTargetWeight');
        const modalCaptureBtn = document.getElementById('modalCaptureBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const modalCalibMsg = document.getElementById('modalCalibMsg');

        const configLoadBtn = document.getElementById('configLoadBtn');
        const configDefaultBtn = document.getElementById('configDefaultBtn');
        const configValidateBtn = document.getElementById('configValidateBtn');
        const configSaveBtn = document.getElementById('configSaveBtn');
        const configRebootBtn = document.getElementById('configRebootBtn');
        const boardConfigEditor = document.getElementById('boardConfigEditor');
        const configStatus = document.getElementById('configStatus');

        let calibrationLiveInterval = null;
        let lastCalibrationRaw = null;
        let lastCalibrationTarget = null;
        let lastCalibrationFactor = null;
        let testRunning = false;
        let testTotalTime = 0; // Store total test time for timer display
        const chartCard = document.getElementById('chartCard');

        window.addEventListener('load', onLoad);

        function onLoad(event) {
            // Set default test name
            const now = new Date();
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = monthNames[now.getMonth()];
            const day = String(now.getDate()).padStart(2, '0');
            const time = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            testNameInput.value = `${month}-${day} Thrust Test - ${time}`;
            updateTestNameDisplay();

            // Set default details and profile
            testDetailsInput.value = "Motor: Sample Motor 2207 1900KV\nProp: 5x4.5x3\nBattery: 4S Lipo\n\nTest Profile: 1200 - 2 - 4; 1600 - 3 - 3; 2000 - 4 - 5; 1000 - 1 - 2";
            
            initWebSocket();
            initChart();
            initButtons();
            initBoardConfig();
            initSimToggle();
            requestScaleFactor();

            testNameInput.addEventListener('input', updateTestNameDisplay);
        }

        function updateTestNameDisplay() {
            if (!testNameDisplay) return;
            const name = testNameInput.value.trim();
            testNameDisplay.textContent = name ? name : '--';
        }

        function initWebSocket() {
            websocket = new WebSocket(gateway);
            websocket.onopen = () => {
                logStatus('Connected to ESP32.');
                setWsStatus('connected');
                requestScaleFactor();
                if (heartbeatTimer) clearInterval(heartbeatTimer);
                heartbeatTimer = setInterval(() => {
                    if (websocket.readyState === WebSocket.OPEN) {
                        sendCommand({ command: 'ping' });
                    }
                }, 5000);
            };
            websocket.onclose = () => {
                logStatus('Connection lost. Retrying...', 'error');
                setWsStatus('disconnected');
                if (heartbeatTimer) {
                    clearInterval(heartbeatTimer);
                    heartbeatTimer = null;
                }
                setTimeout(initWebSocket, 2000);
            };
            websocket.onmessage = onMessage;
        }

        function setWsStatus(state) {
            if (!wsStatusEl || !wsTextEl) return;
            wsStatusEl.dataset.state = state;
            wsTextEl.textContent = state === 'connected' ? 'Connected' : 'Disconnected';
        }

        async function fetchBoardConfigText() {
            const r = await fetch(authUrl('/api/config'), { headers: authHeaders() });
            if (!r.ok) {
                throw new Error('Failed to fetch config');
            }
            return await r.text();
        }

        function parseSimEnabledFromConfig(text) {
            const match = text.match(/^\s*SIM_ENABLED\s*=\s*(\d+)/m);
            if (!match) return false;
            return parseInt(match[1], 10) !== 0;
        }

        function updateSimEnabledInConfig(text, enabled) {
            const value = enabled ? '1' : '0';
            if (/^\s*SIM_ENABLED\s*=\s*\d+/m.test(text)) {
                return text.replace(/^\s*SIM_ENABLED\s*=\s*\d+/m, `SIM_ENABLED = ${value}`);
            }
            if (/^\s*\[sim\]\s*$/m.test(text)) {
                return text.replace(/^\s*\[sim\]\s*$/m, match => `${match}\nSIM_ENABLED = ${value}`);
            }
            return `${text.trimEnd()}\n\n[sim]\nSIM_ENABLED = ${value}\n`;
        }

        async function refreshSimToggle() {
            if (!simToggleEl) return;
            try {
                const text = await fetchBoardConfigText();
                const enabled = parseSimEnabledFromConfig(text);
                simToggleEl.checked = enabled;
            } catch (e) {
                logStatus('Failed to read sim mode.', 'error');
            }
        }

        function initSimToggle() {
            if (!simToggleEl) return;
            refreshSimToggle();
            simToggleEl.addEventListener('change', async function() {
                const desired = simToggleEl.checked;
                simToggleEl.disabled = true;
                try {
                    const text = await fetchBoardConfigText();
                    const current = parseSimEnabledFromConfig(text);
                    if (current === desired) {
                        simToggleEl.disabled = false;
                        return;
                    }
                    const updated = updateSimEnabledInConfig(text, desired);
                    const r = await fetch(authUrl('/api/config'), {
                        method: 'POST',
                        headers: authHeaders({ 'Content-Type': 'text/plain' }),
                        body: updated
                    });
                    if (!r.ok) {
                        throw new Error('Failed to save config');
                    }
                    logStatus(`Simulation ${desired ? 'enabled' : 'disabled'} (reboot to apply).`);
                } catch (e) {
                    logStatus('Failed to update simulation mode.', 'error');
                    simToggleEl.checked = !desired;
                } finally {
                    simToggleEl.disabled = false;
                }
            });
        }

        function requestScaleFactor() {
            sendCommand({ command: 'get_scale_factor' });
        }

        function requestRawReading() {
            sendCommand({ command: 'get_raw_reading' });
        }

        function onMessage(event) {
            const data = JSON.parse(event.data);
            switch (data.type) {
                case 'live_data':
                    updateLiveData(data);
                    break;
                case 'status':
                    logStatus(data.message);
                    if (data.message && data.message.toLowerCase().includes('starting sequence')) {
                        startChartLive();
                    }
                    if (data.message && data.message.toLowerCase().includes('test finished')) {
                        stopChartLive();
                    }
                    break;
                case 'safety_shutdown':
                    logStatus(`SAFETY SHUTDOWN: ${data.message}`, 'error');
                    exportBtn.disabled = true;
                    stopChartLive();
                    break;
                case 'final_results_start':
                    finalResultsReceiving = true;
                    expectedFinalTotal = data.total || 0;
                    finalTestResults = [];
                    resultsSaved = false;
                    exportBtn.disabled = true;
                    logStatus(`Receiving final results (${expectedFinalTotal} points)...`);
                    break;
                case 'final_results_chunk':
                    if (Array.isArray(data.data)) {
                        finalTestResults = finalTestResults.concat(data.data);
                    }
                    break;
                case 'final_results_end':
                    finalResultsReceiving = false;
                    if (expectedFinalTotal > 0 && finalTestResults.length < expectedFinalTotal) {
                        logStatus('Final results incomplete. Attempting recovery from device...');
                        fetchLatestResultsFromDevice().then((recovered) => {
                            if (recovered && recovered.length > 0) {
                                finalTestResults = recovered;
                                applyFinalResults(finalTestResults);
                                logStatus('Recovered results from device.');
                            } else {
                                applyFinalResults(finalTestResults);
                                logStatus('Recovery failed. Results may be incomplete.', 'error');
                            }
                        });
                    } else {
                        applyFinalResults(finalTestResults);
                    }
                    break;
                case 'final_results':
                    // Backward-compatible handler
                    finalTestResults = data.data || [];
                    resultsSaved = false;
                    applyFinalResults(finalTestResults);
                    break;
                case 'scale_factor':
                    updateScaleFactorUI(data.value);
                    break;
                case 'raw_reading':
                    updateRawReadingUI(data.raw, data.weight, data.factor);
                    break;
                case 'pong':
                    break;
            }
        }

        function applyFinalResults(results) {
            logStatus('Final results received. Calculating stats...');
            exportBtn.disabled = !results || results.length === 0;
            plotFinalResults(results || []);
            calculateAndDisplayStats(results || []);
            if (results && results.length > 0) {
                testTotalTime = results[results.length - 1].time / 1000;
                liveTimerEl.textContent = testTotalTime.toFixed(2) + 's';
            }
            testRunning = false;
        }

        function parseResultsCsv(csvText) {
            const lines = csvText.split(/\r?\n/);
            const results = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('timestamp')) continue;
                const parts = trimmed.split(',');
                if (parts.length < 3) continue;
                const t = parseInt(parts[0], 10);
                const thrust = parseFloat(parts[1]);
                const pwm = parseInt(parts[2], 10);
                if (isNaN(t) || isNaN(thrust) || isNaN(pwm)) continue;
                results.push({ time: t, thrust: thrust, pwm: pwm });
            }
            return results;
        }

        async function fetchLatestResultsFromDevice() {
            try {
                const r = await fetch(authUrl('/api/results/latest'), { headers: authHeaders() });
                if (!r.ok) return null;
                const text = await r.text();
                return parseResultsCsv(text);
            } catch (err) {
                return null;
            }
        }

        function confirmDiscardIfNeeded(actionLabel) {
            if (finalTestResults.length > 0 && !resultsSaved) {
                return confirm(`Results are not saved. ${actionLabel} will discard them. Save first?`);
            }
            return true;
        }

        // Chart live update control
        function startChartLive() {
            testRunning = true;
            testTotalTime = 0;
            // Always clear chart for a new run
            if (thrustChart) {
                thrustChart.data.datasets[0].data = [];
                thrustChart.data.datasets[1].data = [];
                thrustChart.update();
            }
        }

        function stopChartLive() {
            testRunning = false;
            // Chart remains visible, timer should show total test time (do not reset)
            if (testTotalTime > 0) {
                liveTimerEl.textContent = testTotalTime.toFixed(2) + 's';
            }
        }

        function updateScaleFactorUI(value) {
            currentScaleFactor = value;
            modalScaleFactorInput.value = value.toFixed(2);
        }

        function updateRawReadingUI(raw, weight, factor) {
            currentRawReading = raw;
            // Use the factor from the input box if user changed it
            let factorToUse = parseFloat(modalScaleFactorInput.value);
            if (isNaN(factorToUse)) factorToUse = factor;
            // Calculate measured weight using the current factor
            let measured = (factorToUse !== 0) ? raw / factorToUse : 0;
            currentMeasuredWeight = measured;
            modalMeasuredWeight.textContent = measured.toFixed(2);
        }

        function initButtons() {
            startBtn.onclick = () => {
                const details = testDetailsInput.value;
                const sequence = extractSequence(details);

                if (sequence) {
                    if (!confirmDiscardIfNeeded('Starting a new test')) {
                        return;
                    }
                    const plannedSeconds = computePlannedSeconds(sequence);
                    resetUI();
                    setPlannedTimeScale(plannedSeconds);
                    if (plannedSeconds) {
                        logStatus(`Planned time scale: ${plannedSeconds}s.`);
                    }
                    logStatus(`Sending sequence to ESP32: ${sequence}`);
                    sendCommand({ command: 'start_test', sequence: sequence });
                } else {
                    alert('Could not find a "Test Profile:" line in the details box.');
                }
            };
            stopBtn.onclick = () => sendCommand({ command: 'stop_test' });
            resetBtn.onclick = () => {
                if (!confirmDiscardIfNeeded('Resetting')) {
                    return;
                }
                sendCommand({ command: 'reset' });
                resetUI();
            };
            exportBtn.onclick = () => exportToCsv();

            // Calibration logic
            calibrateBtn.addEventListener('click', function() {
                modalTargetWeight.value = '';
                modalCalibMsg.textContent = '';
                showCalibrationModal();
                modalScaleFactorInput.value = currentScaleFactor.toFixed(2);
                modalMeasuredWeight.textContent = '...';
                startCalibrationLive();
            });

            modalCancelBtn.addEventListener('click', function() {
                stopCalibrationLive();
                hideCalibrationModal();
            });

            modalCaptureBtn.addEventListener('click', function() {
                const target = parseFloat(modalTargetWeight.value);
                let factorInput = parseFloat(modalScaleFactorInput.value);
                if (isNaN(target) || Math.abs(target) < 0.01) {
                    modalCalibMsg.textContent = "Please enter a valid target weight.";
                    return;
                }
                if (currentRawReading === 0) {
                    modalCalibMsg.textContent = "Raw reading not available. Try again.";
                    return;
                }
                if (lastCalibrationRaw === currentRawReading && lastCalibrationTarget === target) {
                    modalCalibMsg.textContent = `Scale factor unchanged (${lastCalibrationFactor.toFixed(2)}).`;
                    return;
                }
                const newFactor = currentRawReading / target;
                modalScaleFactorInput.value = newFactor.toFixed(2);
                sendCommand({ command: 'set_scale_factor', value: newFactor });
                modalCalibMsg.textContent = `Set scale factor to ${newFactor.toFixed(2)}.`;
                calibrationStatus.textContent = `Scale factor updated to ${newFactor.toFixed(2)}.`;
                lastCalibrationRaw = currentRawReading;
                lastCalibrationTarget = target;
                lastCalibrationFactor = newFactor;
            });

            modalScaleFactorInput.addEventListener('input', function() {
                let factorToUse = parseFloat(modalScaleFactorInput.value);
                if (!isNaN(factorToUse) && currentRawReading !== 0) {
                    let measured = currentRawReading / factorToUse;
                    modalMeasuredWeight.textContent = measured.toFixed(2);
                }
            });

            if (settingsOpenBtn && settingsModal) {
                settingsOpenBtn.addEventListener('click', function() {
                    settingsModal.style.display = 'flex';
                });
            }
            if (settingsCloseBtn && settingsModal) {
                settingsCloseBtn.addEventListener('click', function() {
                    settingsModal.style.display = 'none';
                });
            }
            if (settingsModal) {
                settingsModal.addEventListener('click', function(e) {
                    if (e.target === settingsModal) {
                        settingsModal.style.display = 'none';
                    }
                });
            }
        }

        function initBoardConfig() {
            function setConfigStatus(msg, isError) {
                configStatus.textContent = msg;
                configStatus.style.color = isError ? '#ff6b6b' : '#aaa';
            }
            configLoadBtn.addEventListener('click', async function() {
                setConfigStatus('Loading...');
                try {
                    const r = await fetch(authUrl('/api/config'), { headers: authHeaders() });
                    if (!r.ok) {
                        setConfigStatus('Failed to load config.', true);
                        return;
                    }
                    const text = await r.text();
                    boardConfigEditor.value = text;
                    setConfigStatus('Loaded from board.');
                } catch (e) {
                    setConfigStatus('Request failed.', true);
                }
            });
            configDefaultBtn.addEventListener('click', async function() {
                setConfigStatus('Loading default...');
                try {
                    const r = await fetch(authUrl('/api/config/default'), { headers: authHeaders() });
                    if (!r.ok) {
                        setConfigStatus('Failed to load default.', true);
                        return;
                    }
                    const text = await r.text();
                    boardConfigEditor.value = text;
                    setConfigStatus('Default config loaded. Save to board to apply.');
                } catch (e) {
                    setConfigStatus('Request failed.', true);
                }
            });
            configSaveBtn.addEventListener('click', async function() {
                const content = boardConfigEditor.value;
                if (!content.trim()) {
                    setConfigStatus('Editor is empty.', true);
                    return;
                }
                setConfigStatus('Saving...');
                try {
                    const r = await fetch(authUrl('/api/config'), {
                        method: 'POST',
                        headers: authHeaders({ 'Content-Type': 'text/plain' }),
                        body: content
                    });
                    const data = r.ok ? {} : await r.json().catch(() => ({}));
                    if (r.ok) {
                        setConfigStatus('Saved. Reboot the board to apply pin/ESC changes.');
                    } else {
                        setConfigStatus(data.error || 'Save failed.', true);
                    }
                } catch (e) {
                    setConfigStatus('Request failed.', true);
                }
            });

            configValidateBtn.addEventListener('click', async function() {
                const content = boardConfigEditor.value;
                if (!content.trim()) {
                    setConfigStatus('Editor is empty.', true);
                    return;
                }
                setConfigStatus('Validating...');
                try {
                    const r = await fetch(authUrl('/api/config/validate'), {
                        method: 'POST',
                        headers: authHeaders({ 'Content-Type': 'text/plain' }),
                        body: content
                    });
                    const data = r.ok ? {} : await r.json().catch(() => ({}));
                    if (r.ok) {
                        setConfigStatus('Config valid.');
                    } else {
                        setConfigStatus(data.error || 'Validation failed.', true);
                    }
                } catch (e) {
                    setConfigStatus('Request failed.', true);
                }
            });

            configRebootBtn.addEventListener('click', rebootBoard);
            if (topbarRebootBtn) {
                topbarRebootBtn.addEventListener('click', rebootBoard);
            }
        }

        async function rebootBoard() {
            const confirmed = window.confirm('Reboot the ESP32 now? This will disconnect the UI temporarily.');
            if (!confirmed) return;
            setConfigStatus('Rebooting...');
            logStatus('Rebooting board...');
            try {
                const r = await fetch(authUrl('/api/reboot'), {
                    method: 'POST',
                    headers: authHeaders()
                });
                if (!r.ok) {
                    const data = await r.json().catch(() => ({}));
                    setConfigStatus(data.error || 'Reboot failed.', true);
                    logStatus(data.error || 'Reboot failed.', 'error');
                }
            } catch (e) {
                setConfigStatus('Request failed.', true);
                logStatus('Reboot request failed.', 'error');
            }
        }

        function startCalibrationLive() {
            requestRawReading();
            if (calibrationLiveInterval) clearInterval(calibrationLiveInterval);
            calibrationLiveInterval = setInterval(requestRawReading, 300);
        }

        function stopCalibrationLive() {
            if (calibrationLiveInterval) {
                clearInterval(calibrationLiveInterval);
                calibrationLiveInterval = null;
            }
        }

        function showCalibrationModal() {
            calibrationModal.style.display = 'flex';
            calibrationModal.style.alignItems = 'center';
            calibrationModal.style.justifyContent = 'center';
        }

        function hideCalibrationModal() {
            calibrationModal.style.display = 'none';
        }

        function sendCommand(cmdObject) {
            if (websocket.readyState === WebSocket.OPEN) {
                if (authToken) cmdObject.token = authToken;
                websocket.send(JSON.stringify(cmdObject));
            } else {
                logStatus('WebSocket is not connected.', 'error');
            }
        }

        function logStatus(message, type = 'normal') {
            const p = document.createElement('p');
            p.innerHTML = `&gt; ${message}`;
            if (type === 'error') p.className = 'error-log';
            statusLogEl.prepend(p);
            statusLogEl.scrollTop = 0;
        }

        function resetUI() {
            if (thrustChart) {
                thrustChart.data.datasets[0].data = [];
                thrustChart.data.datasets[1].data = [];
                setPlannedTimeScale(null);
                thrustChart.update();
            }
            currentThrustEl.textContent = "0.00";
            currentPwmEl.textContent = "1000";
            currentVoltageEl.textContent = "--";
            currentCurrentEl.textContent = "--";
            liveTimerEl.textContent = "0.00s";
            exportBtn.disabled = true;
            finalTestResults = [];
            resultsSaved = true;
            summaryCardEl.style.display = 'none';
            testTotalTime = 0;
            logStatus("UI Reset.");
            stopChartLive();
        }

        function computePlannedSeconds(sequence) {
            if (!sequence) return null;
            const steps = sequence.split(';').map(s => s.trim()).filter(Boolean);
            let total = 0;
            for (const step of steps) {
                const match = step.match(/(\d+)\s*-\s*(\d+)\s*-\s*(\d+)/);
                if (!match) return null;
                const spinup = parseInt(match[2], 10);
                const stable = parseInt(match[3], 10);
                if (isNaN(spinup) || isNaN(stable)) return null;
                total += spinup + stable;
            }
            return total > 0 ? total : null;
        }

        function setPlannedTimeScale(seconds) {
            plannedMaxSeconds = seconds;
            if (!thrustChart) return;
            if (seconds && seconds > 0) {
                thrustChart.options.scales.x.min = 0;
                thrustChart.options.scales.x.max = seconds;
            } else {
                delete thrustChart.options.scales.x.min;
                delete thrustChart.options.scales.x.max;
            }
        }

        function extractSequence(details) {
            if (!details) return '';
            const lines = details.split(/\r?\n/);
            let sequence = '';
            for (let i = 0; i < lines.length; i++) {
                if (/^\s*Test Profile:/i.test(lines[i])) {
                    sequence = lines[i].replace(/^\s*Test Profile:\s*/i, '').trim();
                    for (let j = i + 1; j < lines.length; j++) {
                        const line = lines[j].trim();
                        if (line === '') break;
                        if (/\d+\s*-\s*\d+\s*-\s*\d+/.test(line)) {
                            if (sequence && !sequence.trim().endsWith(';')) sequence += '; ';
                            sequence += line;
                        } else if (sequence) {
                            sequence += ' ' + line;
                        }
                    }
                    break;
                }
            }
            if (!sequence) {
                const matches = details.match(/\d+\s*-\s*\d+\s*-\s*\d+/g);
                if (matches) sequence = matches.join('; ');
            }
            return sequence.trim();
        }

        function initChart() {
            const ctx = document.getElementById('thrustChart').getContext('2d');
            thrustChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'PWM (μs)', data: [], borderColor: 'rgba(30, 144, 255, 1)', yAxisID: 'y'
                    }, {
                        label: 'Thrust (g)', data: [], borderColor: 'rgba(233, 69, 96, 1)', yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { type: 'linear', title: { display: true, text: 'Time (s)', color: 'white' }, ticks: { color: 'white' } },
                        y: { 
                            type: 'linear', 
                            display: true, 
                            position: 'left', 
                            title: { display: true, text: 'PWM (μs)', color: 'rgba(30, 144, 255, 1)' }, 
                            ticks: { color: 'rgba(30, 144, 255, 1)' }, 
                            min: 1000,
                            max: 2000,
                            grid: { drawOnChartArea: true }
                        },
                        y1: { 
                            type: 'linear', 
                            display: true, 
                            position: 'right', 
                            title: { display: true, text: 'Thrust (g)', color: 'rgba(233, 69, 96, 1)' }, 
                            ticks: { color: 'rgba(233, 69, 96, 1)' }, 
                            beginAtZero: true,
                            grid: { drawOnChartArea: false }
                        }
                    },
                    plugins: { legend: { labels: { color: 'white' } } }
                }
            });
            const fullDatasetOptions = { borderWidth: 2, fill: false, tension: 0, pointRadius: 0 };
            thrustChart.data.datasets[0] = {...thrustChart.data.datasets[0], ...fullDatasetOptions, backgroundColor: 'rgba(30, 144, 255, 0.1)'};
            thrustChart.data.datasets[1] = {...thrustChart.data.datasets[1], ...fullDatasetOptions, fill: true, backgroundColor: 'rgba(233, 69, 96, 0.2)'};
        }

        let lastThrust = 0.00;
        let lastPwm = 1000;
        let lastVoltage = 0.00;
        let lastCurrent = 0.00;

        function updateLiveData(data) {
            // Defensive: parse numbers in case backend sends strings
            let thrust = (typeof data.thrust === "number") ? data.thrust : parseFloat(data.thrust);
            let pwm = (typeof data.pwm === "number") ? data.pwm : parseFloat(data.pwm);
            let voltage = (typeof data.voltage === "number") ? data.voltage : parseFloat(data.voltage);
            let current = (typeof data.current === "number") ? data.current : parseFloat(data.current);

            const voltageValid = !isNaN(voltage);
            const currentValid = !isNaN(current);

            // Fallback to last value if still NaN (thrust/pwm only)
            thrust = (!isNaN(thrust)) ? thrust : lastThrust;
            pwm = (!isNaN(pwm)) ? pwm : lastPwm;
            if (voltageValid) lastVoltage = voltage;
            if (currentValid) lastCurrent = current;

            // Clamp to reasonable values to avoid wild jumps
            if (Math.abs(thrust - lastThrust) > 1000) thrust = lastThrust;
            if (Math.abs(voltage - lastVoltage) > 10) voltage = lastVoltage;
            if (Math.abs(current - lastCurrent) > 50) current = lastCurrent;

            currentThrustEl.textContent = thrust.toFixed(2);
            currentPwmEl.textContent = pwm;
            if (voltageValid) {
                currentVoltageEl.textContent = voltage.toFixed(2);
            } else {
                currentVoltageEl.textContent = testRunning ? '--' : 'N/A';
            }
            if (currentValid) {
                currentCurrentEl.textContent = current.toFixed(2);
            } else {
                currentCurrentEl.textContent = testRunning ? '--' : 'N/A';
            }

            lastThrust = thrust;
            lastPwm = pwm;
            if (voltageValid) lastVoltage = voltage;
            if (currentValid) lastCurrent = current;

            // Timer logic: use the relative time from the server directly
            if (testRunning) {
                let elapsed = data.time / 1000;
                liveTimerEl.textContent = elapsed.toFixed(2) + 's';
            } else if (testTotalTime > 0) {
                liveTimerEl.textContent = testTotalTime.toFixed(2) + 's';
            } else {
                liveTimerEl.textContent = "0.00s";
            }

            // Only update chart if test is running
            if (testRunning && thrustChart) {
                // data.time is already the correct relative time in ms. Use it directly.
                let chartTime = data.time / 1000;
                thrustChart.data.datasets[0].data.push({ x: chartTime, y: lastPwm });    // PWM (left)
                thrustChart.data.datasets[1].data.push({ x: chartTime, y: lastThrust }); // Thrust (right)

                if (plannedMaxSeconds && chartTime > plannedMaxSeconds) {
                    plannedMaxSeconds = chartTime;
                    thrustChart.options.scales.x.max = plannedMaxSeconds;
                }

                const maxPoints = 8000;
                if (thrustChart.data.datasets[0].data.length > maxPoints) {
                    thrustChart.data.datasets[0].data.shift();
                    thrustChart.data.datasets[1].data.shift();
                }
                thrustChart.update('none');
            }
        }

        function plotFinalResults(results) {
            if (!results || results.length === 0) return;
            const pwmData = [];
            const thrustData = [];
            let maxTime = 0;

            let lastThrustVal = 0.00;
            let lastPwmVal = 1000;

            for (let i = 0; i < results.length; i++) {
                const p = results[i];
                let t = typeof p.thrust === "number" ? p.thrust : parseFloat(p.thrust) || 0;
                let pwm = typeof p.pwm === "number" ? p.pwm : parseFloat(p.pwm) || 0;

                if (Math.abs(t - lastThrustVal) > 1000) t = lastThrustVal;
                if (Math.abs(pwm - lastPwmVal) > 1000) pwm = lastPwmVal;

                const timeSec = p.time / 1000;
                pwmData.push({ x: timeSec, y: pwm });
                thrustData.push({ x: timeSec, y: t });
                if (timeSec > maxTime) maxTime = timeSec;

                lastThrustVal = t;
                lastPwmVal = pwm;
            }

            thrustChart.data.datasets[0].data = pwmData;
            thrustChart.data.datasets[1].data = thrustData;
            if (maxTime > 0) {
                setPlannedTimeScale(maxTime);
            }
            thrustChart.update();
        }

        function calculateAndDisplayStats(results) {
            if (results.length < 2) return;

            let thrustVals = results.map(p => {
                let t = typeof p.thrust === "number" ? p.thrust : parseFloat(p.thrust) || 0;
                return t < 0 ? 0 : t;
            });
            let maxThrust = Math.max.apply(null, thrustVals);
            let maxPwm = Math.max.apply(null, results.map(p => typeof p.pwm === "number" ? p.pwm : parseFloat(p.pwm) || 0));

            const thrustThreshold = maxThrust - 50;
            let timeAtMax = 0;
            for (let i = 1; i < results.length; i++) {
                const t1 = thrustVals[i];
                const t0 = thrustVals[i-1];
                const avgThrustInSegment = (t1 + t0) / 2;
                if (avgThrustInSegment >= thrustThreshold) {
                    const timeDelta = results[i].time - results[i-1].time;
                    timeAtMax += timeDelta;
                }
            }

            const totalTime = results[results.length - 1].time;

            document.getElementById('summaryMaxThrust').textContent = maxThrust.toFixed(2);
            document.getElementById('summaryMaxPwm').textContent = maxPwm;
            document.getElementById('summaryTimeAtMax').textContent = (timeAtMax / 1000).toFixed(2);
            document.getElementById('summaryTotalTime').textContent = (totalTime / 1000).toFixed(2);

            summaryCardEl.style.display = 'block';
        }

        function exportToCsv() {
            // Always use the canonical results from the server
            let exportResults = finalTestResults;

            if (!exportResults || exportResults.length === 0) {
                alert("No results to export. Run a test first.");
                return;
            }

            const now = new Date();
            const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
            const timeStr = `${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
            const testName = testNameInput.value.trim().replace(/[^a-z0-9]/gi, '_') || "ThrustTest";
            const fileName = `${testName}_${dateStr}_${timeStr}.csv`;
            
            let csvContent = "";
            const detailsHeader = testDetailsInput.value.trim().split('\n').map(line => `# ${line}`).join('\n');
            csvContent += detailsHeader + '\n\n';
            csvContent += "timestamp_ms,thrust_g,pwm_us\n";
            exportResults.forEach(row => {
                csvContent += `${row.time},${parseFloat(row.thrust).toFixed(3)},${row.pwm}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            resultsSaved = true;
            logStatus(`Exported results to ${fileName}`);
        }
    </script>
</body>
</html>
